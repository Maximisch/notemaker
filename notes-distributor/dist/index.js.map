{"version":3,"file":"index.js","mappings":";;;;;;AAAA;;;;;;;;AAAA;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../webpack://notes-distributor/../../../usr/local/share/nvm/versions/node/v19.9.0/lib/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack://notes-distributor/webpack/bootstrap","../webpack://notes-distributor/webpack/runtime/compat","../webpack://notes-distributor/./notes-distributor.js"],"sourcesContent":[null,"// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","// Create a javascript github action that traverses all issues in the current repo that are labelled \"account-overview\"\n// Extract the list of keywords from each of those issues (using the keywordsRegex) and create a map of issues to keywords\n// Traverse all issues in the current repo that are not labelled \"account-overview\" and if one of they keywords from the map is found in the issue title, map the issue to the corresponding account-overview issue\n\nconst core = require('@actions/core');\nconst github = require('@actions/github');\nconst token = core.getInput('token');\nconst octokit = github.getOctokit(token);\n\n// TODO Centralize these constants\nconst keywordsRegex = /## Keywords:((\\r\\n)((- .+(\\r\\n)?)*))/g;\nconst relatedIssuesRegex = /## Related Issues:((\\r\\n)?((- \\[[\\sx]\\].+(\\r\\n)?)*))/g;\nconst accountOverviewLabel = \"account-overview\";\n\nlet allAccountOverviewIssues = [];\nlet accountIssueIDsToKeywords = {};\nlet accountIssueIDsToNoteIssueIDs = {};\n\nasync function run() {\n    // Retrieve all issues in the current repo that are labelled \"account-overview\"\n    allAccountOverviewIssues = await octokit.rest.issues.listForRepo({\n        owner: github.context.repo.owner,\n        repo: github.context.repo.repo,\n        labels: accountOverviewLabel\n    }).catch((error) => {\n        core.setFailed(error.message);\n    });\n    \n    // Extract the list of keywords from each of those issues (using the keywordsRegex) and create a map of issues to keywords\n    for (let i = 0; i < allAccountOverviewIssues.data.length; i++) {\n        let issue = allAccountOverviewIssues.data[i];\n        console.log(\"Extracting keywords from issue\", issue.number);\n        let keywords = extractKeywords(issue.body);\n        accountIssueIDsToKeywords[issue.number] = keywords;\n    }\n\n    // Traverse all issues in the current repo that are not labelled \"account-overview\" and if one of they keywords from the map is found in the issue title, map the issue to the corresponding account-overview issue\n    // use pagination\n    const allIssues = await octokit.paginate(\"GET /repos/{owner}/{repo}/issues\", {\n        owner: github.context.repo.owner,\n        repo: github.context.repo.repo,\n        per_page: 100,\n    }).catch((error) => {\n        core.setFailed(error.message);\n    });\n    console.log(\"PrevSize\",allIssues.length);\n    allIssues\n        .filter((issue) => issue.number !== github.context.issue.number)\n        .filter((issue) => issue.labels.filter((label) => label.name === accountOverviewLabel).length === 0)\n        .forEach((issue) => {\n            let issueTitle = issue.title;\n            for (let accountIssueID in accountIssueIDsToKeywords) {\n                let keywords = accountIssueIDsToKeywords[accountIssueID];\n                // Super high fidelity matching\n                if (keywords.some((keyword) => issueTitle.toLowerCase().includes(keyword.toLowerCase()))) {\n                    if (accountIssueIDsToNoteIssueIDs[accountIssueID]) {\n                        accountIssueIDsToNoteIssueIDs[accountIssueID].push(issue.number);\n                    } else {\n                        accountIssueIDsToNoteIssueIDs[accountIssueID] = [issue.number];\n                    }\n                }\n            }\n        });\n    console.log(\"PostSize\", allIssues.length);\n\n    // DEBUG\n    console.log(JSON.stringify(accountIssueIDsToNoteIssueIDs));\n\n\n    // Traverse accountIssueIDsToNoteIssueIDs keys (=account overview issue numbers) and for each one, retrieve the issue body and extract the related issues task list\n    // Once we have extracted the task list, update it to include the mapped issues, while maintaining the existing state (checked/unchecked) of the existing tasks\n    for (let accountIssueID in accountIssueIDsToNoteIssueIDs) {\n        // Store objects of format {issueNumber: issueNumber, checked: true/false} in currentRelatedIssuesTaskList\n        let currentRelatedIssuesTaskList = [];\n        let accountIssue = allIssues.find((issue) => issue.number == accountIssueID);\n        if (!accountIssue) {\n            console.error(\"Could not find account issue\", accountIssueID, \"in the list of all issues, skipping\", JSON.stringify(allIssues));\n            core.setFailed(\"Could not find account issue \" + accountIssueID + \" in the list of all issues, skipping\");\n            return;\n        }\n        let accountIssueBody = accountIssue.body;\n        let match = new RegExp(relatedIssuesRegex).exec(accountIssueBody);\n        if (match) {\n            currentRelatedIssuesTaskLIst = extractRelatedIssues(accountIssueBody);\n        } else {\n            console.log(\"Did not find any existing related issues for account issue\", accountIssueID);\n        }\n        // generate new task list and replace the old one\n        let newRelatedIssuesTaskList = currentRelatedIssuesTaskList;\n        accountIssueIDsToNoteIssueIDs[accountIssueID].forEach((noteIssueID) => {\n            if (newRelatedIssuesTaskList.find((task) => task.issueNumber === noteIssueID)) {\n                console.debug(\"Issue\", noteIssueID, \"already exists in the related issues task list for account issue\", accountIssueID, \", skipping\");\n            } else {\n                console.debug(\"Adding issue\", noteIssueID, \"to the related issues task list for account issue\", accountIssueID);\n                newRelatedIssuesTaskList.push({\n                    issueNumber: noteIssueID,\n                    checked: false,\n                });\n            }\n        });\n        // Generate task list string\n        let newRelatedIssuesTaskListString = \"## Related Issues:\\r\\n\";\n        newRelatedIssuesTaskList.forEach((task) => {\n            newRelatedIssuesTaskListString += `- [${task.checked ? \"x\" : \" \"}] #${task.issueNumber}\\r\\n`;\n        });\n        // Replace the old task list with the new one\n        let newAccountIssueBody = accountIssueBody.replace(new RegExp(relatedIssuesRegex), newRelatedIssuesTaskListString);\n        // Update the issue\n        await octokit.rest.issues.update({\n            owner: github.context.repo.owner,\n            repo: github.context.repo.repo,\n            issue_number: accountIssueID,\n            body: newAccountIssueBody\n        }).catch((error) => {\n            core.setFailed(error.message);\n        });\n    }\n\n\n\n}\n\nrun();\n\nfunction extractKeywords(issueBody) {\n    let keywords = [];\n    let match = new RegExp(keywordsRegex).exec(issueBody);\n    if (match) {\n        let keywordsString = match[1];\n        keywords = keywordsString.split(/\\r\\n/g);\n        console.debug(\"Found keywords, extracting\", JSON.stringify(keywords));\n        let individualKeywordRegex = /- (.+)/g;\n\n        // Extract the keyword from each line\n        keywords = [];\n        while ((match = individualKeywordRegex.exec(keywordsString)) !== null) {\n            keywords.push(match[1]);\n        }\n        console.log(\"Extracted keywords:\", JSON.stringify(keywords));\n    }\n    return keywords;\n}\n\nfunction extractRelatedIssues(issueBody) {\n    let relatedIssues = [];\n    let match = new RegExp(relatedIssuesRegex).exec(issueBody);\n    if (match) {\n        let relatedIssuesString = match[1];\n        relatedIssues = relatedIssuesString.split(/\\r\\n/g);\n        console.debug(\"Found relatedIssues, extracting\", JSON.stringify(relatedIssues));\n        let individualRelatedIssueRegex = /- \\[([\\sx])\\] #(\\d+)/g;\n\n        // Extract the relatedIssue from each line\n        relatedIssues = [];\n        while ((match = individualRelatedIssueRegex.exec(relatedIssuesString)) !== null) {\n            relatedIssues.push({\n                issueNumber: match[2],\n                checked: match[1] === \"x\",\n            });\n        }\n        console.log(\"Extracted relatedIssues:\", JSON.stringify(relatedIssues));\n    }\n    return relatedIssues;\n}\n"],"names":[],"sourceRoot":""}