{"version":3,"file":"index.js","mappings":";;;;;;AAAA;;;;;;;;AAAA;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../webpack://notes-meta-orchestrator/../../../usr/local/share/nvm/versions/node/v19.9.0/lib/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack://notes-meta-orchestrator/webpack/bootstrap","../webpack://notes-meta-orchestrator/webpack/runtime/compat","../webpack://notes-meta-orchestrator/./meta-orchestrator.js"],"sourcesContent":[null,"// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","const core = require('@actions/core');\nconst github = require('@actions/github');\n\n//TODO Add Master Account Tracking URL to the master issue template\nconst masterIssueTemplateRegex = /(<!--(\\r\\n)Note: Please replace the indicated strings \\(format <REPLACE-ME>\\) below and leave the rest unmodified(\\r\\n)-->(\\r\\n)*)?# Account Overview(\\r\\n)## Account ID: ([a-zA-Z0-9-_]+)(\\r\\n)## Target issue URL: ([\\/\\.:a-zA-Z0-9-]+)(\\r\\n)## Autopublish: \\[([\\sx])\\](\\r\\n)## Keywords:((\\r\\n)((- .+(\\r\\n)?)*))(\\r\\n)## Related Issues:((\\r\\n)?((- \\[[\\sx]\\].+(\\r\\n)?)*))/g;\nconst accountIdRegex = /## Account ID: ([a-zA-Z-_]+)(\\r\\n)/g;\nconst targetIssueUrlRegex = /## Target issue URL: ([\\/\\.:a-zA-Z0-9-]+)(\\r\\n)/g;\nconst autopublishRegex = /## Autopublish: \\[([\\sx])\\](\\r\\n)/g;\nconst keywordsRegex = /## Keywords:((\\r\\n)((- .+(\\r\\n)?)*))/g;\n// TODO Enhance tasklist syntax to cover if annotations for ```tasklist {} ```are included\nconst relatedIssuesRegex = /## Related Issues:((\\r\\n)?((- \\[[\\sx]\\].+(\\r\\n)?)*))/g;\n\n\n// Create issue labels if they don't exist (pattern is: <account-ID>)\n// Verify master issue coherence (Has to contain an account-ID, a checkbox for autopublishing, a list of keywords and a tasklist of related issues - which can also be empty)\n// process changes to master issues\n// run on all issue body modifications\n// at runtime first check if it's labeled account-overview (if not terminate)\n// trigger note-publisher if tasklist item was checked off (using matrix strategy output)\nasync function run() {\n    try {\n        const token = core.getInput('token');\n        const octokit = github.getOctokit(token);\n        let targetOctokit;\n        // If we have an input for the target token, use it, otherwise use the default octokit\n        if (core.getInput('targetToken')) {\n            targetOctokit = github.getOctokit(core.getInput('targetToken'));\n        } else {\n            targetOctokit = octokit;\n        }\n\n        // Check if a label with that name already exists, and if yes, terminate\n        const labels = await octokit.rest.issues.listLabelsForRepo({\n            owner: github.context.repo.owner,\n            repo: github.context.repo.repo,\n        });\n\n        // If the context was issue creation, create a new label for the issue with the accountId and label it with the label \"account-overview\" (to create if it does not exist)\n        if (github.context.eventName === 'issues') {\n\n            // If the issue does not contain the label \"account-overview\", terminate\n            if (!github.context.payload.issue.labels.find((label) => label.name === 'account-overview')) {\n                console.error(\"Issue does not contain the label 'account-overview', assuming it's a note and terminating. If you believe this is a mistake, please verify the issue template.\");\n                console.setFailed(\"Issue does not contain the label 'account-overview', assuming it's a note and terminating. If you believe this is a mistake, please verify the issue template.\");\n                return;\n            }\n\n            // Verify issue structure\n            if (! await verifyStructure(github.context.payload.issue.body, octokit)) {\n                console.error(\"Issue structure is not valid\");\n                core.setFailed(\"Issue structure is not valid\");\n                await applyErrorLabel(github.context.payload.issue.number, octokit);\n                return;\n            } else {\n                console.log(\"Issue structure is valid\");\n                // Remove error label if it is applied\n                let issueLabels = github.context.payload.issue.labels.map((label) => label.name);\n                if (issueLabels.includes('invalid-issue-structure')) {\n                    await octokit.rest.issues.removeLabel({\n                        owner: github.context.repo.owner,\n                        repo: github.context.repo.repo,\n                        issue_number: github.context.payload.issue.number,\n                        name: 'invalid-issue-structure'\n                    });\n                }\n            }\n            \n            // If the issue was edited: Determine differences and act accordingly\n            if (github.context.payload.action === 'edited') {\n                // Check if the tasklist was updated by comparing the old and new body\n                // if yes, check if the tasklist item was checked off\n                // if yes, trigger note-publisher\n                // if no, terminate\n                \n                let sourceIssueUrl = github.context.payload.issue.html_url;\n                let oldBody = github.context.payload.changes.body.from;\n                let newBody = github.context.payload.issue.body;\n\n                // a tasklist item has two fields, checked (boolean) and reference (string)\n                let oldTasklistItems = getTasklistEntries(oldBody);\n                let newTasklistItems = getTasklistEntries(newBody);\n\n                console.log(\"Old tasklist items: \", oldTasklistItems);\n                console.log(\"New tasklist items: \", newTasklistItems);\n\n                // check if the tasklist was updated\n                let diffItems = newTasklistItems.filter(x => !oldTasklistItems.some(y => y.reference === x.reference && y.checked === x.checked));\n                if (diffItems.length === 0) {\n                    console.log(\"Tasklist was not updated\");\n                } else {\n                    console.log(\"Tasklist was potentially updated\");\n                    \n                    autopublish = new RegExp(autopublishRegex).exec(github.context.payload.issue.body)[1] === \"x\";\n                    // Check if autopublish is checked, and if yes, trigger note-publisher for every newly added tasklist item\n                    // Else, check if the tasklist item was checked off\n                    let checkedItems = diffItems.filter(x => autopublish || x.checked === true);\n                    if (checkedItems.length === 0) {\n                        console.log(\"Tasklist item was not checked off\");\n                    } else {\n                        console.log(\"Tasklist item was checked off\");\n                        let targetIssueUrl = new RegExp(targetIssueUrlRegex).exec(github.context.payload.issue.body)[1];\n                        console.log(\"Triggering note-publisher\", checkedItems, targetIssueUrl);\n                        await checkedItems\n                            .forEach(async (item) => {\n                                let issueNumber = item.reference.substring(1);\n                                let createdComment = await publishNote(issueNumber, sourceIssueUrl, targetIssueUrl, octokit, targetOctokit);\n                                // Add reference to created comment to the issue\n                                await addCreationComment(issueNumber, createdComment, octokit);\n                                item.checked = true;\n                            });\n                        // Update tasklist correspondingly (check off items published)\n                        let newBodyUpdated = updateTasklist(newTasklistItems, newBody);\n                        await octokit.rest.issues.update({\n                            owner: github.context.repo.owner,\n                            repo: github.context.repo.repo,\n                            issue_number: github.context.payload.issue.number,\n                            body: newBodyUpdated\n                        });\n                    }\n                }\n            } else if (github.context.payload.action === 'opened') {\n                // Issue was created: Setup labeling for this account\n\n                // Create a new label for the account if it doesn't exist yet\n                const accountId = new RegExp(accountIdRegex).exec(github.context.payload.issue.body)[1];\n                const labelName = `${accountId}`;\n                if (labels.data.find((label) => label.name === labelName)) {\n                    console.error(`Label with name \"${labelName}\" already exists`);\n                    core.setFailed(`Label with name \"${labelName}\" already exists`);\n                    await applyErrorLabel(github.context.payload.issue.number, octokit);\n                    return;\n                } else {\n                    console.log(\"Creating label\", labelName);\n                    // create the label\n                    await octokit.rest.issues.createLabel({\n                        owner: github.context.repo.owner,\n                        repo: github.context.repo.repo,\n                        name: labelName,\n                        description: 'This label is used to identify issues that are related to the account-overview of a specific account',\n                    });\n                    console.log(\"Label successfully created\", labelName);\n\n                }\n                // Set output to trigger issue distribution action in actions workflow\n                console.log(\"Setting output to trigger issue distribution action\")\n                core.setOutput(\"trigger-distribution\", \"true\");\n\n                // Apply account overview and account-id labels to the issue\n                console.log(\"Applying labels\", ['account-overview', labelName]);\n                await octokit.rest.issues.addLabels({\n                    owner: github.context.repo.owner,\n                    repo: github.context.repo.repo,\n                    issue_number: github.context.payload.issue.number,\n                    labels: ['account-overview', labelName],\n                });\n                console.log(\"Labels successfully applied\", ['account-overview', labelName]);\n            } else {\n                console.error(\"Action not supported\", github.context.payload.action);\n                core.setFailed(\"Action not supported\" +  github.context.payload.action);\n                await applyErrorLabel(github.context.payload.issue.number, octokit);\n                return;\n            }            \n        } else {\n            console.error(\"Only issues trigger is allowed\");\n            core.setFailed(\"Only issues trigger is allowed\");\n            return;\n        }\n    } catch (error) {\n        console.error(error);\n        core.setFailed(error.message);\n    }\n}\n\nfunction updateTasklist(newTasklistItems, newBody) {\n    let newBodyUpdated = newBody;\n    newTasklistItems.forEach((item) => {\n        let tasklistRegex = /- \\[\\s\\] #${item.reference}/g;\n        newBodyUpdated = newBodyUpdated.replace(tasklistRegex, `- [x] ${item.reference}`);\n    });\n    return newBodyUpdated;\n}\n\nfunction getTasklistEntries(issueBody) {\n    let tasklistItems = [];\n    let tasklistRegex = /- \\[([\\sx])\\] (.+)/g;\n    let tasklistMatch;\n    while ((tasklistMatch = tasklistRegex.exec(issueBody)) !== null) {\n        tasklistItems.push({\n            checked: tasklistMatch[1] === 'x',\n            reference: tasklistMatch[2]\n        });\n    }\n    return tasklistItems;\n}\n\nasync function verifyStructure(issueBody, octokit) {\n    // Check if a label with that name already exists, and if yes, terminate\n    const labels = await octokit.rest.issues.listLabelsForRepo({\n        owner: github.context.repo.owner,\n        repo: github.context.repo.repo,\n    });\n\n    // Check if the issue body matches the masterIssueTemplateRegex\n    let masterIssueTemplateMatch = masterIssueTemplateRegex.test(github.context.payload.issue.body);\n    if (! masterIssueTemplateMatch) {\n        console.error(\"Issue body does not match the master issue template\");\n        core.setFailed(\"Issue body does not match the master issue template\");\n        // check which sub-regexes match\n        let matchSubRegexes = {\n            masterIssueTemplateMatch : masterIssueTemplateMatch,\n            accountIdRegex : new RegExp(accountIdRegex).test(github.context.payload.issue.body),\n            targetIssueUrlRegex : new RegExp(targetIssueUrlRegex).test(github.context.payload.issue.body),\n            autopublishRegex : new RegExp(autopublishRegex).test(github.context.payload.issue.body),\n            keywordsRegex : new RegExp(keywordsRegex).test(github.context.payload.issue.body),\n            relatedIssuesRegex : new RegExp(relatedIssuesRegex).test(github.context.payload.issue.body),\n        };\n        console.log(JSON.stringify(matchSubRegexes));\n        return false;\n    } else {\n        console.log(\"Issue body matches the master issue template\");\n        // check if the account ID is valid (must be a string of at least 1 character and alphanumeric characters, dashes and underscores are allowed)\n        let accountId = new RegExp(accountIdRegex).exec(github.context.payload.issue.body)[1];\n        let accountIdValid = accountId.match(/^[a-zA-Z-_]+$/);\n        if (!accountIdValid) {\n            console.error(\"Account ID is not valid, must only contain alphanumeric characters, dashes and underscores\");\n            core.setFailed(\"Account ID is not valid, must only contain alphanumeric characters, dashes and underscores\");\n            return false;\n        }\n\n        // check if the target issue URL is valid\n        let targetIssueUrl = new RegExp(targetIssueUrlRegex).exec(github.context.payload.issue.body)[1];\n        let targetIssueUrlValid = targetIssueUrl.match(/https:\\/\\/github.com\\/[a-zA-Z0-9-_]+\\/[a-zA-Z0-9-_]+\\/issues\\/[0-9]+/);\n        if (!targetIssueUrlValid) {\n            console.error(\"Target issue URL is not valid, must be a valid GitHub issue URL\");\n            core.setFailed(\"Target issue URL is not valid, must be a valid GitHub issue URL\");\n            return false;\n        }\n        \n        // check if the keywords are valid (at least one keyword is required)\n        let keywords = new RegExp(keywordsRegex).exec(github.context.payload.issue.body)[1];\n        let keywordsValid = keywords.match(/^- .+/gm);\n        if (!keywordsValid) {\n            console.error(\"Keywords are not valid, at least one keyword is required\");\n            core.setFailed(\"Keywords are not valid, at least one keyword is required\");\n            return false;\n        }\n\n        // check if the related issues are valid\n        // (Can either be empty, or a tasklist that contains an arbitrary count of only issue references in the form of #<issue-number>)\n        let relatedIssues = new RegExp(relatedIssuesRegex).exec(github.context.payload.issue.body)[1];\n        let relatedIssuesValid = relatedIssues.trim() == \"\" || relatedIssues.match(/^- \\[[\\sx]\\] #\\d+/gm);\n        if (!relatedIssuesValid) {\n            console.error(\"Related issues are not valid, can either be empty or a tasklist that contains an arbitrary count of only issue references in the form of #<issue-number>\");\n            core.setFailed(\"Related issues are not valid, can either be empty or a tasklist that contains an arbitrary count of only issue references in the form of #<issue-number>\");\n            return false;\n        }\n    }\n    return true;\n}\n\nasync function applyErrorLabel(issueNumber, octokit) {\n    //Create error label if it doesn't exist yet\n    let labels = await octokit.rest.issues.listLabelsForRepo({\n        owner: github.context.repo.owner,\n        repo: github.context.repo.repo,\n    });\n    if (!labels.data.find((label) => label.name === 'invalid-issue-structure')) {\n        console.log(\"Creating invalid-issue-structure label..\");\n        await octokit.rest.issues.createLabel({\n            owner: github.context.repo.owner,\n            repo: github.context.repo.repo,\n            name: 'invalid-issue-structure',\n            color: 'dc2626',\n            description: 'This label is used to identify note-keeping system rule-incompliant issues.',\n        });\n    }\n    // Apply error label to the issue\n    await octokit.rest.issues.addLabels({\n        owner: github.context.repo.owner,\n        repo: github.context.repo.repo,\n        issue_number: issueNumber,\n        labels: ['invalid-issue-structure'],\n    });\n}\n\nasync function publishNote(issueNumber, sourceIssueUrl, targetIssueUrl, octokitSource, octokitTarget) {\n    let noteIssue = await octokitSource.rest.issues.get({\n        owner: github.context.repo.owner,\n        repo: github.context.repo.repo,\n        issue_number: issueNumber,\n    });\n    // Retrieve the note issue title\n    let issueTitle = noteIssue.data.title;\n    let issueBody = noteIssue.data.body;\n    // Assemble the comment text\n    let commentText = `# ${issueTitle}\\r\\n\\r\\n${issueBody}\\r\\n\\r\\n_This note was published by the [note-keeping system](https://github.com/maximisch/notemaker)._`;\n    // Create a comment on the target issue\n    let targetIssueOwner = new RegExp(/https:\\/\\/github.com\\/([a-zA-Z0-9-_]+)\\/[a-zA-Z0-9-_]+\\/issues\\/[0-9]+/).exec(targetIssueUrl)[1];\n    let targetIssueRepo = new RegExp(/https:\\/\\/github.com\\/[a-zA-Z0-9-_]+\\/([a-zA-Z0-9-_]+)\\/issues\\/[0-9]+/).exec(targetIssueUrl)[1];\n    let targetIssueNumber = new RegExp(/https:\\/\\/github.com\\/[a-zA-Z0-9-_]+\\/[a-zA-Z0-9-_]+\\/issues\\/([0-9]+)/).exec(targetIssueUrl)[1];\n    console.log(\"Extracted target issue information for comment posting\", targetIssueOwner, targetIssueRepo, targetIssueNumber);\n    return await octokitTarget.rest.issues.createComment({\n        owner: targetIssueOwner,\n        repo: targetIssueRepo,\n        issue_number: targetIssueNumber,\n        body: commentText,\n    });\n}\n\n// Adds a comment to the account tracking issue that a note was published to the target issue\nasync function addCreationComment(issueNumber, createdComment, octokit) {\n    // Assemble the comment text\n    let commentText = `The issue #${issueNumber} was [published successfully](${createdComment.data.html_url})!`;\n    // Create a comment on the account tracking issue\n    await octokit.rest.issues.createComment({\n        owner: github.context.repo.owner,\n        repo: github.context.repo.repo,\n        issue_number: github.context.payload.issue.number,\n        body: commentText,\n    });\n}\n\n// Call the run function\nrun();"],"names":[],"sourceRoot":""}